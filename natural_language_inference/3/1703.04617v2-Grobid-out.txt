title
Exploring Question Understanding and Adaptation in Neural-Network-Based Question Answering
abstract
The last several years have seen intensive interest in exploring neural-networkbased models for machine comprehension (MC) and question answering (QA). In this paper, we approach the problems by closely modelling questions in a neural network framework. We first introduce syntactic information to help encode questions. We then view and model different types of questions and the information shared among them as an adaptation task and proposed adaptation models for them. On the Stanford Question Answering Dataset (SQuAD), we show that these approaches can help attain better results over a competitive baseline.
Introduction
Enabling computers to understand given documents and answer questions about their content has recently attracted intensive interest, including but not limited to the efforts as in. Many specific problems such as machine comprehension and question answering often involve modeling such question-document pairs.
The recent availability of relatively large training datasets (see Section 2 for more details) has made it more feasible to train and estimate rather complex models in an end-to-end fashion for these problems, in which a whole model is fit directly with given question-answer tuples and the resulting model has shown to be rather effective.
In this paper, we take a closer look at modeling questions in such an end-to-end neural network framework, since we regard question understanding is of importance for such problems. We first introduced syntactic information to help encode questions. We then viewed and modelled different types of questions and the information shared among them as an adaptation problem and proposed adaptation models for them. On the Stanford Question Answering Dataset (SQuAD), we show that these approaches can help attain better results on our competitive baselines. named entities, common nouns, verbs, and prepositions to test reading comprehension. The Stanford Question Answering Dataset (SQuAD) is more recently released dataset, which consists of more than 100,000 questions for documents taken from Wikipedia across a wide range of topics. The question-answer pairs are annotated through crowdsourcing. Answers are spans of text marked in the original documents. In this paper, we use SQuAD to evaluate our models.
Many neural network models have been studied on the SQuAD task. proposed match LSTM to associate documents and questions and adapted the so-called pointer Network to determine the positions of the answer text spans. proposed a dynamic chunk reader to extract and rank a set of answer candidates. focused on word representation and presented a fine-grained gating mechanism to dynamically combine word-level and character-level representations based on the properties of words.  proposed a multi-perspective context matching (MPCM) model, which matched an encoded document and question from multiple perspectives. proposed a dynamic decoder and so-called highway maxout network to improve the effectiveness of the decoder. The bi-directional attention flow (BIDAF) used the bi-directional attention to obtain a question-aware context representation.
In this paper, we introduce syntactic information to encode questions with a specific form of recursive neural networks. More specifically, we explore a tree-structured LSTM which extends the linear-chain long short-term memory (LSTM)] to a recursive structure, which has the potential to capture long-distance interactions over the structures.
Different types of questions are often used to seek for different types of information. For example, a "what" question could have very different property from that of a "why" question, while they may share information and need to be trained together instead of separately. We view this as a "adaptation" problem to let different types of questions share a basic model but still discriminate them when needed. Specifically, we are motivated by the ideas "i-vector" in speech recognition, where neural network based adaptation is performed among different (groups) of speakers and we focused instead on different types of questions here.

Word embedding
We concatenate embedding at two levels to represent a word: the character composition and word-level embedding. The character composition feeds all characters of a word into a convolutional neural network (CNN) to obtain a representation for the word. And we use the pre-trained 300-D GloVe vectors (see the experiment section for details) to initialize our word-level embedding. Each word is therefore represented as the concatenation of the character-composition vector and word-level embedding. This is performed on both questions and documents, resulting in two matrices: the Q e ? RN ×dw fora question and the D e ? R M ×dw fora document, where N is the question length (number of word tokens), M is the document length, and d w is the embedding dimensionality.

Input encoding
The above word representation focuses on representing individual words, and an input encoder here employs recurrent neural networks to obtain the representation of a word under its context. We use bi-directional GRU (BiGRU) for both documents and questions.
A BiGRU runs a forward and backward GRU on a sequence starting from the left and the right end, respectively. By concatenating the hidden states of these two GRUs for each word, we obtain the a representation fora question or document: Q c ? RN ×dc fora question and D c ? R M ×dc fora document.
Alignment Questions and documents interact closely. As inmost previous work, our framework use both soft attention over questions and that over documents to capture the interaction between them. More specifically, in this soft-alignment layer, we first feed the contextual representation matrix Q c and D c to obtain alignment matrix U ? RN ×M :
Each U ij represents the similarity between a question word Q c i and a document word D c j . Word-level Q-code Similar as in, we obtain a word-level Q-code. Specifically, for each document word w j , we find which words in the question are relevant to it. To this end, a j ? RN is computed with the following equation and used as a soft attention weight:
With the attention weights computed, we obtain the encoding of the question for each document word w j as follows, which we call word-level Q-code in this paper:
Question-based filtering To better explore question understanding, we design this question-based filtering layer. As detailed later, different question representation can be easily incorporated to this layer in addition to being used as a filter to find key information in the document based on the question. This layer is expandable with more complicated question modeling.
In the basic form of question-based filtering, for each question word w i , we find which words in the document are associated. Similar to a j discussed above, we can obtain the attention weights on document words for each question word w i :
By pooling b ? RN ×M , we can obtain a question-based filtering weight bf :
where the specific pooling function we used include max-pooling and mean-pooling. Then the document softly filtered based on the corresponding question D f can be calculated by:
Through concatenating the document representation D c , word-level Q-code Q wand question-filtered document D f , we can finally obtain the alignment layer representation:
where "•" stands for element-wise multiplication and "?" is simply the vector subtraction.
Aggregation After acquiring the local alignment representation, key information in document and question has been collected, and the aggregation layer is then performed to find answers. We use three BiGRU layers to model the process that aggregates local information to make the global decision to find the answer spans. We found a residual architecture as described in is very effective in this aggregation process: Prediction The SQuAD QA task requires a span of text to answer a question. We use a pointer network to predict the starting and end position of answers as in. Different from their methods, we use a two-directional prediction to obtain the positions. For one direction, we first predict the starting position of the answer span followed by predicting the end position, which is implemented with the following equations:
where I 3 is inference layer output, h s+ is the hidden state of the first step, and all Ware trainable matrices. We also perform this by predicting the end position first and then the starting position:
We finally identify the span of an answer with the following equation:
P (e) = pooling([P (e+), P (e?)]) (21) We use the mean-pooling here as it is more effective on the development set than the alternatives such as the max-pooling.

Question Understanding and Adaptation

Introducing syntactic information for neural question encoding
The interplay of syntax and semantics of natural language questions is of interest for question representation. We attempt to incorporate syntactic information in questions representation with TreeLSTM. In general a TreeLSTM could perform semantic composition over given syntactic structures.
Unlike the chain-structured LSTM, the TreeLSTM captures long-distance interaction on a tree. The update of a TreeLSTM node is described at a high level with Equation, and the detailed computation is described in (23-29). Specifically, the input of a TreeLSTM node is used to configure four gates: the input gate it , output gate o t , and the two forget gates f Lt for the left child input and f R t for the right. The memory cell ct considers each child's cell vector, c L t?1 and c R t?1 , which are gated by the left forget gate f Lt and right forget gate f R t , respectively.
where ? is the sigmoid function, • is the element-wise multiplication of two vectors, and all W, U are trainable matrices.
To obtain the parse tree information, we use Stanford CoreNLP (PCFG Parser)] to produce a binarized constituency parse for each question and build the TreeLSTM based on the parse tree. The root node of TreeLSTM is used as the representation for the whole question. More specifically, we use it as TreeLSTM Q-code Q T L ? R dc , by not only simply concatenating it to the alignment layer output but also using it as a question filter, just as we discussed in the question-based filtering section:
where I new is the new output of alignment layer, and function repmat copies Q T L for M times to fit with I.

Question Adaptation
Questions by nature are often composed to fulfill different types of information needs. For example, a "when" question seeks for different types of information (i.e., temporal information) than those fora "why" question. Different types of questions and the corresponding answers could potentially have different distributional regularity.
Explicit question-type embedding The previous models are often trained for all questions without explicitly discriminating different question types; however, fora target question, both the common features shared by all questions and the specific features fora specific type of question are further considered in this paper, as they could potentially obey different distributions. In this paper we further explicitly model different types of questions in the end-to-end training. We start from a simple way to first analyze the word frequency of all questions, and obtain top-10 most frequent question types: what, how, who, when, which, where, why, be, whose, and whom, in which be stands for the questions beginning with different forms of the word be such as is, am, and are. We explicitly encode question-type information to bean 11-dimensional one-hot vector (the top-10 question types and "other" question type). Each question type is with a trainable embedding vector. We call this explicit question type code, ET ? Rd ET . Then the vector for each question type is tuned during training, and is added to the system with the following equation:
Question adaptation As discussed, different types of questions and their answers may share common regularity and have separate property at the same time. We also view this as an adaptation problem in order to let different types of questions share a basic model but still discriminate them when needed. Specifically, we borrow ideas from speaker adaptation in speech recognition, where neural-network-based adaptation is performed among different groups of speakers.
Conceptually we regard a type of questions as a group of acoustically similar speakers. Specifically we propose a question discriminative block or simply called a discriminative block) below to perform question adaptation. The main idea is described below:
For each input question x, we can decompose it to two parts: the cluster it belong(i.e., question type) and the diverse in the cluster. The information of the cluster is encoded in a vectorx c . In order to keep calculation differentiable, we compute the weight of all the clusters based on the distances of x and each cluster center vector, instead of just choosing the closest cluster. Then the discriminative vector ? x with regard to these most relevant clusters are computed. All this information is combined to obtain the discriminative information. In order to keep the full information of input, we also copy the input question x, together with the acquired discriminative information, to a feed-forward layer to obtain anew representation x for the question. More specifically, the adaptation algorithm contains two steps: adapting and updating, which is detailed as follows:
• Adapting In the adapting step, we first compute the similarity score between an input question vector x ? Rh and each centroid vector of K clustersx ? R K×h . Each cluster here models a question type. Unlike the explicit question type modeling discussed above, here we do not specify what question types we are modeling but let the system to learn. Specifically, we only need to pre-specific how many clusters, K, we are modeling. The similarity between an input question and cluster centroid can be used to compute similarity weight w a : w a k = sof tmax(cos_sim(x,x k ), ?), ?k ? [1, . . . , K]
We set ? equals 50 to make sure only closest class will have a high weight while maintain differentiable. Then we acquire a soft class-center vectorx c :
We then compute a discriminative vector ? x between the input question with regard to the soft class-center vector:
Note thatx c here models the cluster information and ? x represents the discriminative information in the cluster. By feeding x,x c and ? x into feedforward layer with Relu, we obtain x ? R K :
With x ready, we can apply Discriminative Block to any question code and obtain its adaptation Q-code. In this paper, we use TreeLSTM Q-code as the input vector x, and obtain TreeLSTM adaptation Q-code Q T La ? R dc . Similar to TreeLSTM Q-code Q T L , we concatenate Q T La to alignment output I and also use it as a question filter:
The updating stage attempts to modify the center vectors of the K clusters in order to fit each cluster to model different types of questions. The updating is performed according to the following formula:
In the equation, ? is an updating rate used to control the amount of each updating, and we set it to 0.01. When x is faraway from K-th cluster centerx k , w a k is close to be value 0 and the k-th cluster centerx k tends not to be updated. If x is instead close to the j-th cluster centerx j , w a k is close to the value 1 and the centroid of the j-th clusterx j will be updated more aggressively using x.

Experiment Results

Set-Up
We test our models on Stanford Question Answering Dataset (SQuAD). The SQuAD dataset consists of more than 100,000 questions annotated by crowdsourcing workers on a selected set of Wikipedia articles, and the answer to each question is a span of text in the Wikipedia articles. Training data includes 87,599 instances and validation set has 10,570 instances. The test data is hidden and kept by the organizer. The evaluation of SQuAD is Exact Match (EM) and F1 score.
We use pre-trained 300-D Glove 840B vectors to initialize our word embeddings. Out-of-vocabulary (OOV) words are initialized randomly with Gaussian samples. CharCNN filter length is 1,3,5, each is 50 dimensions. All vectors including word embedding are updated during training. The cluster number K in discriminative block is 100. The Adam method is used for optimization. And the first momentum is set to be 0.9 and the second 0.999. The initial learning rate is 0.0004 and the batch size is 32. We will half learning rate when meet a bad iteration, and the patience is 7. Our early stop evaluation is the EM and F1 score of validation set. All hidden states of GRUs, and TreeLSTMs are 500 dimensions, while word-level embedding d w is 300 dimensions. We set max length of document to 500, and drop the question-document pairs beyond this on training set. Explicit question-type dimension d ET is 50. We apply dropout to the Encoder layer and aggregation layer with a dropout rate of 0.5.

Model

EM F1
Logistic Regression Baseline 40.4 51.0
Match-LSTM with Ans-Ptr (Sentence) 54.505 67.748 Match-LSTM with Ans-Ptr (Boundary) 60.474 70.695 Dynamic Chunk Reader 62.499 70.956 Fine-Grained Gating  62.446 73.327 Match-LSTM with Bi-Ans-Ptr (Boundary) 64.744 73.743 Multi-Perspective Matching  65.551 75.118 Dynamic Coattention Networks 66

Results
Overall results shows the official leaderboard on SQuAD test set when we submitted our system. Our model achieves a 68.73% EM score and 77.39% F1 score, which is ranked among the state of the art single models (without model ensembling shows the ablation performances of various Q-code on the development set. Note that since the testset is hidden from us, we can only perform such an analysis on the development set. Our baseline model using no Q-code achieved a 68.00% and 77.36% EM and F1 scores, respectively. When we added the explicit question type T-code into the baseline model, the performance was improved slightly to 68.16%(EM) and 77.58%(F1). We then used TreeLSTM introduce syntactic parses for question representation and understanding (replacing simple question type as question understanding Q-code), which consistently shows further improvement. We further incorporated the soft adaptation. When letting the number of hidden question types (K) to be 20, the performance improves to 68.73%/77.74% on EM and F1, respectively, which corresponds to the results of our model reported in. Furthermore, after submitted our result, we have experimented with a large value of K and found that when K = 100, we can achieve a better performance of 69.10%/78.38% on the development set. shows the EM/F1 scores of different question types while is the question type amount distribution on the development set. In we can see that the average EM/F1 of the "when" question is highest and those of the "why" question is the lowest. From we can seethe "what" question is the major class. shows the composition of F1 score. Take our best model as an example, we observed a 78.38% F1 score on the whole development set, which can be separated into two parts: one is where F1 score equals to 100%, which means an exact match. This part accounts for 69.10% of the entire development set. And the other part accounts for 30.90%, of which the average F1 score is 30.03%. For the latter, we can further divide it into two sub-parts: one is where the F1 score equals to 0%, which means that predict answer is totally wrong. This part occupies 14.89% of the total development set. The other part accounts for 16.01% of the development set, of which average F1 score is 57.96%. From this analysis we can see that reducing the zero F1 score (14.89%) is potentially an important direction to further improve the system.: F1 Score Analysis.

Conclusions
Closely modelling questions could be of importance for question answering and machine reading. In this paper, we introduce syntactic information to help encode questions in neural networks. We view and model different types of questions and the information shared among them as an adaptation task and proposed adaptation models for them. On the Stanford Question Answering Dataset (SQuAD), we show that these approaches can help attain better results over a competitive baseline.