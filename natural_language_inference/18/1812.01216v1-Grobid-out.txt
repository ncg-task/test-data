title
Parameter Re-Initialization through Cyclical Batch Size Schedules
abstract
Optimal parameter initialization remains a crucial problem for neural network training. A poor weight initialization may take longer to train and/or converge to sub-optimal solutions. Here, we propose a method of weight re-initialization by repeated annealing and injection of noise in the training process. We implement this through a cyclical batch size schedule motivated by a Bayesian perspective of neural network training. We evaluate our methods through extensive experiments on tasks in language modeling, natural language inference, and image classification. We demonstrate the ability of our method to improve language modeling performance by up to 7.91 perplexity and reduce training iterations by up to 61%, in addition to its flexibility in enabling snapshot ensembling and use with adversarial training.
Introduction
Despite many promising empirical results at using stochastic optimization methods to train highly non-convex modern deep neural networks, we still lack theoretically robust practical methods which are able to escape saddle points and/or sub-optimal local minima and converge to parameters that retain high testing performance. This lack of understanding leads to practical training challenges.
Stochastic Gradient Descent (SGD) is currently the de-facto optimization method for training deep neural networks (DNNs). Through extensive hyper-parameter tuning, SGD can avoid poor local optima and achieve good generalization ability. One important hyper-parameter that can significantly affect SGD performance is the weight initialization. For instance, initializing the weights to all zeros or all ones leads to extremely poor performance. Different approaches have been proposed for weight initialization such as Xavier, MSRA, Ortho, LSUV. These are mostly agnostic to the model architecture and the specific learning task.
Our work explores the idea of adapting the weight initialization to the optimization dynamics of the specific learning task at hand. From the Bayesian perspective, improved weight initialization can be viewed as starting with a better prior, which leads to a more accurate posterior and thus better generalization ability. This problem has been explored extensively in Bayesian optimization. For example, in the seminal works, an adaptive prior is implemented via Markov Chain Monte Carlo (MCMC) methods. Motivated by these ideas, we incorporate an "adaptive initialization" for neural network training (see section 2 for details), where we use cyclical batch size schedules to control the noise (or temperature) of SGD. As argued in, both learning rate and batch size can be used to control the noise of SGD but the latter has an advantage in that it allows more parallelization opportunity. The idea of using batch size to control the noise in a simple cyclical schedule was recently proposed in. Here, we build upon this work by studying different cyclical annealing strategies fora wide range of problems. Additionally, we discuss how this can be combined with anew adversarial regularization scheme recently proposed in, as well as prior work in order to obtain ensembles of models at no additional cost. In summary, our contributions are as follows:
• We explore different cyclical batch size (CBS) schedules for training neural networks inspired by Bayesian statistics, particularly adaptive MCMC methods. The CBS schedule leads to multiple perplexity improvement (up to 7.91) in language modeling and minor improvements in natural language inference and image classification. Furthermore, we show that CBS schedule can alleviate problems with overfitting and sub-optimal parameter initialization. • Additionally, CBS schedules require up to 3× fewer SGD iterations due to larger batch sizes, which allows for more parallelization opportunity. This reflects the benefit of cycling the batch size instead of the learning rate as in prior work • We showcase the flexibility of CBS schedules for use with additional techniques. We propose a simple but effective ensembling method that combines models saved during different cycles at no additional training cost. In addition, we show that CBS schedule can be combined with other approaches such as the recently proposed adversarial regularization to yield further classification accuracy improvement of 0.26%.

Related Work
[5] introduced Xavier initialization, which keeps the variance of input and output of all layers within a similar range in order to prevent vanishing or exploding values in both the forward and backward passes. Building off this idea, explored anew strategy known as MSRA to keep the variance constant for all convolutional layers. proposed an orthogonal initialization (Ortho) to achieve faster convergence, and more recently, combined ideas from previous work and showed that a unit variance orthogonal initialization is beneficial for deep models. show that the noise of SGD is controlled by the ratio of learning rate to batch size. The authors argued that the SGD algorithm can be derived through Euler-Maruyama discretization of a Stochastic Differential Equation (SDE). The SDE dynamics are governed by a "noise scale" g ? N/B for the learning rate, N the training dataset size, and B the batch size. They conclude that a higher noise scale prevents SGD from settling into sharper minima. This result supports a prior empirical observation that under certain mild assumptions such as NB, the effect of dividing the learning rate by a constant factor is equivalent to that of multiplying the batch size by the same constant factor. In related work, applied this understanding and used batch size as a knob to control the noise, and empirically showed that the baseline performance could be matched. further explored how to use second-order information and adversarial training to control the noise for training large batch size. showed using a statistical mechanics argument that many other hyper-parameters in neural network training, e.g. data quality, can also act as temperature knobs.

Methods
The goal of neural network optimization is to solve an empirical risk minimization, with a loss function of the form:
where ? is the model parameters, X is the training dataset and l(x, ?) is the loss function. Here N = |X| is the cardinality of the training set. In SGD, a mini-batch, B ? {1, 2, ..., N } is used to compute an (unbiased) gradient, i.e., gt = 1
|B| x?B ? ? l(x, ? t ), and this is typically used to optimize (1) in the form:
where ? t is the learning rate (step size) at iteration t, and commonly annealed during training.
By Bayes' Theorem, given the input data, X, a prior distribution on the model parameters, P (?), and a likelihood function, P (X|?), the posterior distribution, P (?|X), is:
From this Bayesian perspective, the goal of the neural network training is to find the Maximum-A-Posteriori (MAP) point fora given prior distribution. Note that in this context weight initialization and prior distribution are similar, that is a better prior distribution would lead to more informative posterior. In general, it maybe difficult to design a better prior given only data and a model architecture. Additionally, the high dimensionality of the NN's parameter space renders various approaches such as adaptive priors intractable (e.g. adaptive MCMC algorithms). Hence, we look into an adaptive weight "re-initialization" strategy. We start with an input prior (weight initialization) and compute an approximate MAP point by annealing the noise in SGD. Once we compute the MAP point, we use it as anew initialization of the neural network weights, and restart the noise annealing schedule. We then iteratively repeat this process through the training process.
One approach to controlling the level of noise in SGD is via the learning rate, which is the approach used in. However, as discussed in, the batch size can also be used to control SGD noise. The motivation for this is that larger batch sizes allow for parallel execution which can accelerate training. We implement weight re-initialization through cyclical batch size schedules. The SGD training process is divided into one or more cycles, and in single cycle we gradually increase the batch size to decrease noise. As the noise level of SGD is annealed, ? will approaches a local minima i.e., an approximate MAP point of P (?|X). Then at the beginning of the subsequent cycle we drop the batch size back down to the initial value, which increases the noise in SGD and "re-initializes" the neural network parameters using the previous estimate. Several CBS schedules are shown in.

Results
We perform a variety of experiments across different tasks and neural network architectures in natural language processing as well as image classification. We report our experimental findings on language tasks in section 3.1, and image classification in section 3.2. We illustrate that CBS schedules can alleviate sub-optimal initialization in section 3.3. We follow the baseline training method for each task (for details please see Appendix A). Alongside testing/validation performance, we also report the number of training iterations (lower values are preferred).

Language Results
Language modeling is a challenging problem due to the complex and long-range interactions between distant words. One hope is that large/deep models might be able to capture these complex interactions, but large models easily overfit on these tasks and exhibit large gaps between training set and testing set performance. CBS schedules effectively help us avoid overfitting, and in addition snapshot ensembling enables even greater performance.
We evaluate a large variety of CBS schedules to positive results as shown in. Results are measured in perplexity, a standard figure of merit for evaluating the quality of language models by measuring its prediction of the empirical distribution of words (lower perplexity value is better). As we can see, the best performing CBS schedules result in significant improvements in perplexity (up to 7.91) over the baseline schedules and also offer reductions in the number of SGD training iterations (up to 33%). For example, CBS schedules achieve improvement of 7.91 perplexity improvement on WikiText 2 via CBS-1-T and reduce the SGD iterations from 164k to 111k via the CBS-1-A schedule. Notice that almost all CBS schedules outperform the baseline schedule. shows the training and testing perplexity of the L2 model on PTB and WikiTest 2 as trained via the baseline schedule along with our best CBS schedule (from). Notice the cyclical spikes in  training and testing perplexity. The peaks occur during decreases in batch size, i.e., increases in noise scale, which could help to escape sub-optimal local minima, and the troughs occur during increases in batch size, i.e., decreases with noise scale.
In order to support our claim that CBS schedules are especially useful for counteracting overfitting, we conducted additional language modeling experiments on models L1', L2' with PTB and WT2 which use significantly lower dropout (0.2 and 0.3) than the original L1, L2 models (0.5 and 0.65). Because these models heavily overfit the training data, we report both the final testing perplexity as well as the best testing perplexity achieve during training. As seen in To further explore the properties of cyclical batch size schedules, we also evaluate these schedules on natural language inference tasks, as shown in. In our experiments, CBS schedules do not yield large performance improvements on models like E1 which exhibit smaller disparities between training and testing performance. This is inline with our limitation in that CBS is more effective for models which tend to overfit. On the other hand, we see a large reduction in training iterations by up to 62% which is due to higher effective batch size used in CBS than baseline. We also test our CBS schedules on Cifar-10 and ImageNet. 3 reports the testing accuracy and the number of training iterations for different models on Cifar-10. We see that the CBS schedules match baseline performance, but the number of training iterations used in CBS schedules is up to 2× fewer.

Image Classification Results
As seen in, the training curves of CBS schedules also exhibit the aforementioned cyclical spikes both in training loss and testing accuracy. Similarly in the previously discussed language experiments, these spikes correspond to cycles in the CBS schedules and can bethought of as re-initializations of the neural network weights. We observe that CBS achieves similar performance to the baseline. We offer further support for the hypothesis that CBS schedules are more effective for overfitting neural networks with experiments on model C4, which achieves 94.35% training accuracy and 55.55% testing accuracy on Cifar-10. With CBS-15, we see 90.71% training accuracy and 56.44% testing accuracy, which is a larger improvement than that offered by CBS on convolutional models on Cifar-10.
We also explore combining CBS with the recent adversarial regularization proposed by. Combining CBS-15 on C2 with this strategy improves accuracy to 94.82%. This outperforms other schedules shown in. Applying snapshot ensembling on C3 trained with CBS-15-2 leads to improved accuracy of 93.56% as compared to 92.58%. After ensembling ResNet50 on Imagenet with snapshots from the last two cycles, the performance increases to 76.401% from 75.336%.

Sub-optimal Initialization
Various effective initialization methods have been proposed previously; however, when presented with new architectures and new tasks, initialization still needs to be explored empirically and often the final performance varies greatly with different initializations. In this section, we test if CBS schedules can alleviate the problem of sub-optimal initialization.
We test a Gaussian initialization with mean 0 and standard deviation 0.1 on an AlexNet-like model (C1). The baseline (BL) training follows the same setting as described in Appendix A and achieves final accuracy 84.27%. For CBS, we use cycle width of 10 with 3 steps. In particular, CBS 1 denotes a constant learning rate, and achieves final accuracy 85.41%. CBS 2 decays the learning rate by a factor of 5 at epoch 75 and achieves final accuracy 84.95%. We keep learning rate high during training because a high noise level helps ? escape sub-optimal local minima. Notice that all CBS methods achieve better generalization performance than the baseline.

Conclusions
In this work we explored different cyclical batch size (CBS) schedules for training neural networks. We framed the motivation behind CBS schedules through the lens of Bayesian statistical methods, in particular adaptive MCMC algorithms, which seek out better estimates of the posterior starting with a (poor) prior distribution. In the context of neural network training, this translates to re-initialization of the weights via cycling between large and small batch sizes which control the noise in SGD. We show empirical results which find this cyclical batch size schedule can significantly outperform fixed batch size baselines, especially in networks prone to overfitting or initialized poorly, on the tasks of language modeling, natural language inference, and image classification with LSTMs, CNNs, and ResNets. In our language modeling experiments, we see that a wide variety of CBS schedules outperform the baseline by up to 7.91 perplexity and up to 33% fewer training iterations. For natural language inference and image classification tasks, we observe a reduction in the number of training iterations of up to 61%, which translates directly into reduced runtime. Finally, we demonstrate the flexibility of CBS as a building block for ensembling and adversarial training methods. Ensembling on language modeling yields improvements of up to 11.22 perplexity over the baseline and on image classification, an improvement of up to 1.07% accuracy. Adversarial training in conjunction with CBS gives a bump in image classification accuracy of 0.26%.

Limitations
We believe that it is very important for every work to state its limitations (in general, but in particular in this area). We performed an extensive variety of experiments on different tasks in order to comprehensively test the algorithm. The primary limitation of our work is that cyclical batch size schedules introduce another hyper-parameter that requires manual tuning. We note that this is also true for cyclical learning rate schedules, and hope to address this using second order methods as part of future work. Furthermore, for well initialized models which are not prone to overfitting, single snapshot CBS achieves similar performance to the baseline, although the cyclical ensembling provides a modicum of improvement.

A Training Details
Here we catalogue details regarding all tasks, datasets, models, batch schedules, and other hyperparameters used in our experiments. In all experiments, we try to copy as many hyper-parameters from the original papers as possible.
Tasks: We train networks to perform the following supervised learning tasks:
• Image classification. The network is trained to classify the content of images within a fixed set of object classes. • Language modeling. The network is trained to predict the last token in a sequence of English words. • Natural Language Inference. The network is trained to classify the relationship between pairs of English sentences such as that of entailment, contradiction, or neutral.

Datasets:
We train networks on the following datasets.
• Cifar (image classification). The two Cifar (i.e., Cifar-10/Cifar-100) datasets contain 50k training images and 10k testing images, and 10/100 label classes. • ImageNet (image classification). The ILSVRC 2012 classification dataset consists of 1000 label classes, with a total of 1.2 million training images and 50,000 validation images. During training, we crop the image to 224 × 224. • PTB (language modeling). The Penn Tree Bank dataset consists of preprocessed and tokenized sentences from the Wall Street Journal. The training set is 929k words, the validation set 73k words, and test set 82k words. The total vocabulary size is 10k, and all words outside the vocabulary are replaced by a placeholder token. • WikiText 2 (language modeling). The Wikitext 2 dataset is modeled after the Penn Tree Bank dataset and consists of preprocessed and tokenized sentences from Wikipedia. The training set is 2089k words, the validation set 218k words, and the test set 246k words. The total vocabulary size is 33k, and all words outside the vocabulary are replaced by a placeholder token. • SNLI (natural language inference). The SNLI dataset consists of pairs of sentences annotated with one of three labels regarding textual entailment information: contradiction, neutral, or entailment. The training set contains 550k pairs, and the validation set contains 10k pairs. • MultiNLI (natural language inference. The MultiNLI dataset is modeled after the SNLI dataset and contains a training set of 393k pairs and a validation set of 20k pairs.
Model Architecture. We implement the following neural network architectures.
• C1. AlexNet-like on Cifar-10 dataset as in[C1], trained on the task of image classification. We train for 200 epochs with an initial learning rate 0.02 which we decay by a factor of 5 at epoch 30, 60. In particular, we use initial learning rate 0.05 for cyclic scheduling. • C2. WResNet 16-4 on Cifar-10 dataset, trained on the task of image classification. We train for 200 epochs with an initial learning rate 0.1 which we decay by a factor of 5 at epoch 60, 120, and 180. • C3. ResNet20 on Cifar-10 dataset. We train it for 160 epochs with initial learning rate 0.1, and decay a factor of 5 at epoch 80, 120. In particular, we use initial learning rate 0.05 for cyclic scheduling. • C4. MLP3 network from. The network consists of 3 fully connected layers with 512 units each and ReLU activations. As a baseline, we train this network with vanilla SGD for 240 epochs with a batch size of 100 and an initial learning rate of 0.1, which is decayed by a factor of 10 at 150 and 225 epochs. • I1. ResNet50 on ImageNet dataset, trained on the task of image classification for 90 epochs with initial learning rate 0.1 which we decay by a factor of 10 at epoch 30, 60 and 80. • L1. Medium Regularized LSTM, trained on the task of language modeling. We use 50% dropout on non-recurrent connections and train for 39 epochs with initial learning rate of 20, decaying by a factor of 1.2 every epoch after epoch 6. We set a backpropagation-through-time limit of 35 steps and clip the max gradient norm at 0.25. • L2. Large Regularized LSTM, trained on the task of language modeling. We use 65% dropout on non-recurrent connections and train for 55 epochs with initial learning rate of 20, decaying by a factor of 1.15 every epoch after epoch We set a backpropagation-through-time limit of 35 steps and clip the max gradient norm at 0.5.
• L1', L2' Identical to L1, L2 except for lower dropout: 0.2, 0.3 respectively. Leads to significant overfitting, evidenced by test perplexity curve in. • E1. ESIM. We train the base ESIM model without the tree-LSTM, as in, on the task of natural language inference with ADAM for 10 epochs on MultiNLI and also SNLI.
Training Schedules: We use the following batch size schedules
• BL. Use a fixed small batch size as specified in the original paper introducing the model or as is standard. • CBS-k(-n). Use a Cyclical Batch Size schedule, where k is the width of each step measured in epochs and n is the integer number of steps per cycle. When n is not specified it refers to the default value of 4. At the beginning of each cycle the batch size is initialized to the base batch size, and after each step it is then doubled. • CBS-k(-n)-A. Use an aggressive Cyclical Batch Size schedule, which is equivalent to the original CBS schedule except after every step the batch size is quadrupled. • CBS-k(-n)-T. Use a triangular Cyclical Batch Size schedule, which is modeled after the triangular schedule. Each cycle consists of n steps doubling the batch size after each step, then n ? 2 symmetrical steps halving the batch size after each step.
In all language modeling CBS experiments, we use an initial batch size of 10, that is, half the baseline batch size as reported in the respective papers of each baseline model tested. The intuition behind starting with a smaller batch size is to introduce additional noise to help models escape sub-optimal local minima.
For adversarial training used in image classification, we use FGSM method to generate adversarial examples. Adversarial training is implemented for the first half training epochs.

B Additional Results
This section shows additional experiment results.