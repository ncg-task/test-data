title
FaceBoxes : A CPU Real - time Face Detector with High Accuracy
abstract
Although tremendous strides have been made in face detection , one of the remaining open challenges is to achieve real - time speed on the CPU as well as maintain high performance , since effective models for face detection tend to be computationally prohibitive .
To address this challenge , we propose a novel face detector , named FaceBoxes , with superior performance on both speed and accuracy .
Specifically , our method has a lightweight yet powerful network structure that consists of the Rapidly Digested Convolutional Layers ( RDCL ) and the Multiple Scale Convolutional Layers ( MSCL ) .
The RDCL is designed to enable Face - Boxes to achieve real - time speed on the CPU .
The MSCL aims at enriching the receptive fields and discretizing anchors over different layers to handle faces of various scales .
Besides , we propose a new anchor densification strategy to make different types of anchors have the same density on the image , which significantly improves the recall rate of small faces .
As a consequence , the proposed detector runs at 20 FPS on a single CPU core and 125 FPS using a GPU for VGA - resolution images .
Moreover , the speed of FaceBoxes is invariant to the number of faces .
We comprehensively evaluate this method and present stateof - the - art detection performance on several face detection benchmark datasets , including the AFW , PASCAL face , and FDDB .
Code is available at https://github.com/sfzhang15/FaceBoxes .
Introduction
Face detection is one of the fundamental problems in computer vision and pattern recognition .
It plays an important role in many subsequent face - related applications , such as face alignment , face recognition and face tracking .
With the great progress over the past few decades , especially the breakthrough of convolutional neural network , face detection has been successfully applied in our daily life under various scenarios .
However , there are still some tough challenges in uncontrolled face detection problem , especially for the CPU devices .
The challenges mainly come from two requirements for face detectors :
1 ) The large visual variation of faces in the cluttered backgrounds requires face detectors to accurately address a complicated face and non-face classification problem ; 2 ) The large search space of possible face positions and face sizes further imposes a time efficiency requirement .
These two requirements are conflicting , since high - accuracy face detectors tend to be computationally expensive .
Therefore , it is one of the remaining open issues for practical face detectors on the CPU devices to achieve real - time speed as well as maintain high performance .
In order to meet these two conflicting requirements , face detection has been intensely studied mainly in two ways .
The early way is based on hand - craft features .
Following the pioneering work of Viola - Jones face detector , most of the early works focus on designing robust features and training effective classifiers .
Besides the cascade structure , the deformable part model ( DPM ) is introduced into face detection tasks and achieves remarkable performance .
However , these methods highly depend on nonrobust hand - craft features and optimize each component separately , making the face detection pipeline sub-optimal .
In brief , they are efficient on the CPU but not accurate enough against the large visual variation of faces .
The other way is based on the convolutional neural network ( CNN ) which has achieved remarkable successes in recent years , ranging from image classification to object detection .
Recently , CNN has been successfully introduced into the face detection task as feature extractor in the traditional face detection framewrok .
Moreover , some face detectors have inherited valid techniques from the generic object detection methods , such as Faster R - CNN .
These CNN based face detection methods are robust to the large variation of facial appearances and demonstrate state - of - the - art performance .
But they are too time - consuming to achieve real - time speed , especially on the CPU devices .
These two ways have their own advantages .
The former has fast speed while the latter owns high accuracy .
To perform well on both speed and accuracy , one natural idea is to combine the advantages of these two types of methods .
Therefore , cascaded CNN based methods are proposed to put features learned by CNN into cascade framework in order to boost the performance and keep efficient .
However , there are three problems in cascaded CNN based methods :
1 ) Their speed is negatively related to the number of faces on the image .
The speed would dramatically degrade as the number of faces increases ; 2 ) The cascade based detectors optimize each component separately , making the training process extremely complicated and the final model sub-optimal ; 3 ) For the VGA - resolution images , their runtime efficiency on the CPU is about 14 FPS , which is not fast enough to reach the real - time speed .
In this paper , inspired by the RPN in Faster R - CNN and the multi-scale mechanism in SSD , we develop a state - of - the - art face detector with real - time speed on the CPU .
Specifically , we propose a novel face detector named FaceBoxes , which only contains a single fully convolutional neural network and can be trained end - to - end .
The proposed method has a lightweight yet powerful network structure ( as shown in ) that consists of the Rapidly Digested Convolutional Layers ( RDCL ) and the Multiple Scale Convolutional Layers ( MSCL ) .
The RDCL is designed to enable FaceBoxes to achieve real - time speed on the CPU , and the MSCL aims at enriching the receptive fields and discretizing anchors over different layers to handle various scales of faces .
Besides , we propose a new anchor densification strategy to make different types of anchors have the same density on the input image , which significantly improves the recall rate of small faces .
Consequently , for VGA - resolution images , our face detector runs at 20 FPS on a single CPU core and 125 FPS using a GPU .
More importantly , the speed of FaceBoxes is invariant to the number of faces on the image .
We comprehensively evaluate this method and demonstrate state - of - the - art detection performance on several face detection benchmark datasets , including the AFW , PASCAL face , and FDDB .
For clarity , the main contributions of this work can be summarized as four - fold :
We design the Rapidly Digested Convolutional Layers ( RDCL ) to enable face detection to achieve real - time speed on the CPU ; We introduce the Multiple Scale Convolutional Layers ( MSCL ) to handle various scales of face via enriching receptive fields and discretizing anchors over layers .
We present a new anchor densification strategy to improve the recall rate of small faces ; We further improve the state - of - the - art performance on the AFW , PASCAL face , and FDDB datasets .
The rest of the paper is organized as follows .
Section 2 reviews the related work .
Analysis of the FaceBoxes is presented in section
3 . Section 4 shows the experimental results and section 5 concludes the paper .
Related work
Modern face detection approaches can be roughly divided into two different categories .
One is based on handcraft features , and the other one is built on CNN .
This section briefly reviews these two kinds of methods .
Hand - craft based methods
Previous face detection systems are mostly based on hand - craft features .
Since the seminal Viola - Jones face detector that proposes to combine Haar feature , Adaboost learning and cascade inference for face detection , many subsequent works are proposed for real - time face detection , such as new local features , new boosting algorithms and new cascade structures .
Besides the cascade framework , methods based on structural models progressively achieve better performance and become more and more efficient .
Some researches introduce the deformable part model ( DPM ) into face detection tasks .
These works use supervised parts , more pose partition , better training or more efficient inference to achieve remarkable detection performance .
CNN based methods
The first use of CNN for face detection can be traced back to 1994 .
Vaillant et al.
use a trained CNN in a sliding windows manner to detect faces .
Rowley et al .
introduce a retinally connected neural network for upright frontal face detection , and a " router " network designed to estimate the orientation for rotation invariant face detection .
Garcia et al.
develop a neural network to detect semi-frontal faces .
Osadchy et al. train a CNN for simultaneous face detection and pose estimation .
These earlier methods can get relatively good performance only on easy dataset .
Recent years have witnessed the advance of CNN based face detectors .
CCF uses boosting on top of CNN features for face detection .
Farfade et al.
fine - tune CNN model trained on 1 k Image Net classification task for face and non-face classification task .
Faceness trains a series of CNNs for facial attribute recognition to detect partially occluded faces .
CascadeCNN develops a cascade architecture built on CNNs with powerful discriminative capability and high performance .
Qin et al. propose to jointly train CascadeCNN to realize end - to - end optimization .
Similar to , MTCNN proposes a multi- task cascaded CNNs based framework for joint face detection and alignment .
UnitBox introduces a new intersectionover - union loss function .
CMS - RCNN uses Faster R - CNN in face detection with body contextual information .
Convnet integrates CNN with 3 D face model in an endto - end multi - task learning framework .
STN proposes a new supervised transformer network and a ROI convolution for face detection .
FaceBoxes
This section presents our three contributions that make the FaceBoxes accurate and efficient on the CPU devices : the Rapidly Digested Convolutional Layers ( RDCL ) , the Multiple Scale Convolutional Layers ( MSCL ) and the anchor densification strategy .
Finally , we introduce the associated training methodology .
Rapidly Digested Convolutional Layers
Most of the CNN based face detection methods are usually limited by the heavy cost of time , especially on the CPU devices .
More precisely , the convolution operation for CPU is extremely time - consuming when the size of input , kernel and output are large .
Our RDCL is designed to fast shrink the input spatial size by suitable kernel size with reducing the number of output channels , enabling the FaceBoxes to reach real - time speed on the CPU devices as follows :
Shrinking the spatial size of input :
To rapidly shrink the spatial size of input , our RDCL sets a series of large stride sizes for its convolution and pooling layers .
As illustrated in , the stride size of Conv1 , Pool1 , Conv2 and Pool2 are 4 , 2 , 2 and 2 , respectively .
The total stride size of RDCL is 32 , which means the input spatial size is reduced by 32 times quickly .
Choosing suitable kernel size :
The kernel size of the first few layers in one network should be small so as to speedup , while it is also supposed to be large enough to alleviate the information loss brought by the spatial size reducing .
As shown in , to keep efficient as well as effective , we choose 77 , 55 and 33 kernel size for Conv1 , Conv2 and all Pool layers , respectively .
Reducing the number of output channels :
We utilize the C. ReLU activation function ( illustrated in ) to reduce the number of output channels .
C.ReLU is motivated from the observation in CNN that the filters in the lower layers form pairs ( i.e. , filters with opposite phase ) .
From this observation , C. ReLU can double the number of output channels by simply concatenating negated outputs before applying ReLU .
Using C.ReLU significantly increases speed with negligible decline inaccuracy .
Multiple Scale Convolutional Layers
The proposed method is based on RPN which is developed as a class - agnostic proposer in the scenario of multicategory object detection .
For the single - category detection task ( e.g. , face detection ) , RPN is naturally a detector for the only category concerned .
However , as a stand - alone face detector , RPN is notable to obtain competitive performances .
We argue that such unsatisfactory performance comes from two aspects .
Firstly , the anchors in the RPN are only associated with the last convolutional layer whose feature and resolution are too weak to handle faces of various sizes .
Secondly , an anchor-associated layer is responsible for detecting faces within a corresponding range of scales , but it only has a single receptive field that can not match different scales of faces .
To solve the above two problems , our MSCL is designed along the following two dimensions :
Multi - scale design along the dimension of network depth .
As shown in , our designed MSCL consists of several layers .
These layers decrease in size progressively and form the multi-scale feature maps .
Similar to , our default anchors are associated with multi-scale feature maps ( i.e. , Inception3 , Conv3 2 and Conv4 2 ) .
These layers , as a multi-scale design along the dimension of network depth , discretize anchors over multiple layers with different resolutions to naturally handle faces of various sizes .
Multi-scale design along the dimension of network width .
To learn visual patterns for different scales of faces , output features of the anchor-associated layers should correspond to various sizes of receptive fields , which can be easily fulfilled via Inception modules .
The Inception module consists of multiple convolution branches with different kernels .
These branches , as a multi-scale design along the dimension of network width , is able to enrich the receptive fields .
As shown in , the first three layers in MSCL are based on the Inception module .
illustrates our Inception implementation , which is a cost-effective module to capture different scales of faces .
Anchor densification strategy
As illustrated in , we impose 1:1 aspect ratio for the default anchors ( i.e. , square anchor ) , because the face box is approximately square .
The scale of anchor for the Incep-tion3 layer is 32 , 64 and 128 pixels , for the Conv3 2 layer and Conv4 2 layer are 256 and 512 pixels , respectively .
The tiling interval of anchor on the image is equal to the stride size of the corresponding anchor-associated layer .
For example , the stride size of Conv3 2 is 64 pixels and its anchor is 256 256 , indicating that there is a 256 256 anchor for every 64 pixels on the input image .
We define the tiling density of anchor ( i.e. , A density ) as follows :
Here , A scale is the scale of anchor and A interval is the tiling interval of anchor .
The tiling intervals for our default anchors are 32 , 32 , 32 , 64 and 128 , respectively .
According to Equ. ( 1 ) , the corresponding densities are 1 , 2 , 4 , 4 and 4 , where it is obviously that there is a tiling density imbalance problem between anchors of different scales .
Comparing with large anchors ( i.e. , 128128 , 256256 and 512512 ) , small anchors ( i.e. , 32 32 and 64 64 ) are too sparse , which results in low recall rate of small faces .
To eliminate this imbalance , we propose a new anchor densification strategy .
Specifically , to densify one type of anchors n times , we uniformly tile A number = n 2 anchors around the center of one receptive field instead of only tiling one at the center of this receptive field to predict .
Some examples are shown in .
In our paper , to improve the tiling density of the small anchor , our strategy is used to densify the 32 32 anchor 4 times and the 64 64 anchor 2 times , which guarantees that different scales of anchor have the same density ( i.e. , 4 ) on the image , so that various scales of faces can match almost the same number of anchors .
Training
This subsection introduces the training dataset , data augmentation , matching strategy , loss function , hard negative mining , and other implementation details .
Training dataset .
Our model is trained on 12 , 880 images of the WIDER FACE training subset .
Data augmentation .
Each training image is sequentially processed by the following data augmentation strategies :
Color distortion :
Applying some photo-metric distortions similar to . Random cropping :
We randomly crop five square patches from the original image : one is the biggest square patch , and the size of the others range between [ 0.3 , 1 ] of the short size of the original image .
Then we arbitrarily select one patch for subsequent operations .
Scale transformation :
After random cropping , the selected square patch is resized to 1024 1024 . Horizontal flipping :
The resized image is horizontally flipped with probability of 0.5 .
Face - box filter :
We keep the overlapped part of the face box if its center is in the above processed image , then filter out these face boxes whose height or width is less than 20 pixels .
Matching strategy .
During training , we need to determine which anchors correspond to a face bounding box .
We first match each face to the anchor with the best jaccard overlap , and then match anchors to any face with jaccard overlap higher than a threshold ( i.e. , 0.35 ) .
Loss function .
Our loss function is the same as RPN in Faster R - CNN .
We adopt a 2 - class softmax loss for classification and the smooth L1 loss for regression .
Hard negative mining .
After the anchor matching step , most of the anchors are found to be negative , which introduces a significant imbalance between the positive and negative examples .
For faster optimization and stable training , we sort them by the loss values and pick the top ones so that the ratio between the negatives and positives is at most 3:1 .
Other implementation details .
All the parameters are randomly initialized with the " xavier " method .
We finetune the resulting model using SGD with 0.9 momentum , 0.0005 weight decay and batch size 32 .
The maximum number of iterations is 120 k and we use 10 ? 3 learning rate for the first 80 k iterations , then continue training for 20 k iterations with 10 ? 4 and 10 ? 5 , respectively .
Our method is implemented in the Caffe library .
Experiments
In this section , we firstly introduce the runtime efficiency of FaceBoxes , then analyze our model in an ablative way , finally evaluate it on the common face detection benchmarks .
Runtime efficiency
CNN based methods have always been accused of its runtime efficiency .
Although the existing CNN face detectors can be accelerated via high - end GPUs , they are not fast enough inmost practical applications , especially CPU based applications .
As described below , our FaceBoxes is efficient enough to meet practical requirements .
During inference , our method outputs a large number of boxes ( e.g. , 8 , 525 boxes fora VGA-resolution image ) .
We first filter out most boxes by a confidence threshold of 0.05 and keep the top 400 boxes before applying NMS , then we perform NMS with jaccard overlap of 0.3 and keep the top 200 boxes .
We measure the speed using Titan X ( Pascal ) and cuDNN v 5.1 with Intel Xeon E5-2660v3@2.60 GHz .
As listed in Tab. 1 , comparing with recent CNN - based methods , our FaceBoxes can run at 20 FPS on the CPU with state - of - the - art accuracy .
Besides , our method can run at 125 FPS using a single GPU and has only 4.1 MB in size. , it s m AP is the true positive rate at 179 false positives and with ROI convolution , its FPS can be accelerated to 30 with 0.6 % recall rate drop .
Approach
Model analysis
We carried out extensive ablation experiments on the FDDB dataset to analyze our model .
Comparing with AFW and PASCAL face , FDDB is much more difficult so that analyzing our model on FDDB is convincing .
For all the experiments , we use the same settings , except for specified changes to the components .
Ablative Setting .
To better understand FaceBoxes , we ablate each component one after another to examine how each proposed component affects the final performance .
1 ) Firstly , we ablate the anchor densification strategy .
2 ) Then , we replace MSCL with three convolutional layers , which all have 3 3 kernel size and whose output number is the same as the first three Inception modules of MSCL .
Meantime , we only associate the anchors with the last convolutional layer .
3 ) Finally , we take the place of C. ReLU with ReLU in RDCL .
The ablative results are listed in Tab .
2 and some promising conclusions can be summed up as follows :
Contribution
FaceBoxes Anchor densification strategy is crucial .
Our anchor densification strategy is used to increase the density of small anchors ( i.e. , 32 32 and 64 64 ) in order to improve the recall rate of small faces .
From the results listed in Tab .
2 , we can see that the m AP on FDDB is reduced from 96.0 % to 94.9 % after ablating the anchor densification strategy .
The sharp decline ( i.e. , 1.1 % ) demonstrates the effectiveness of the proposed anchor densification strategy .
MSCL is better .
The comparison between the second and third columns in Tab .
2 indicates that MSCL effectively increases the m AP by 1.0 % , owning to the diverse receptive fields and the multi -scale anchor tiling mechanism .
RDCL is efficient and accuracy - preserving .
The design of RDCL enables our FaceBoxes to achieve real - time speed on the CPU .
As reported in Tab .
2 , RDCL leads to a negligible decline on accuracy but a significant improvement on speed .
Specifically , the FDDB mAP decreases by 0.1 % in return for the about 19.3 ms speed improvement .
Evaluation on benchmark
We evaluate the FaceBoxes on the common face detection benchmark datasets , including Annotated Faces in the Wild ( AFW ) , PASCAL Face , and Face Detection Data Set and Benchmark ( FDDB ) .
AFW dataset .
It has 205 images with 473 faces .
We evaluate FaceBoxes against the well - known works and commercial face detectors ( e.g. , Face.com , Face + + and Picasa ) .
As illustrated in , our FaceBoxes outperforms all others by a large margin .
shows some qualitative results on the AFW dataset .
PASCAL face dataset .
It is collected from the test set of PASCAL person layout dataset , consisting of 1335 faces with large face appearance and pose variations from 851 images .
shows the precision - recall curves on this dataset .
Our method significantly outperforms all other methods and commercial face detectors ( e.g. , SkyBiometry , Face + + and Picasa ) .
shows some qualitative results on the PASCAL face dataset .
FDDB dataset .
It has 5 , 171 faces in 2 , 845 images taken from news articles on Yahoo websites .
FDDB adopts the bounding ellipse , while our FaceBoxes outputs rectangle bounding box .
This inconsistency has a great impact to the continuous score .
For a more fair comparison under the continuous score evaluation , we train an elliptical regressor to transform our predicted bounding boxes to bounding ellipses .
We evaluate our face detector on FDDB against the other methods .
The results are shown in and .
Our FaceBoxes achieves the state - of - the - art performance and outperforms all others by a large margin on discontinuous and continuous ROC curves .
These results indicate that our FaceBoxes can robustly detect unconstrained faces .
shows some qualitative results on the FDDB .
Conclusion
Since effective models for the face detection task tend to be computationally prohibitive , it is challenging for the CPU devices to achieve real - time speed as well as maintain high performance .
In this work , we present a novel face detector with superior performance on both speed and accuracy .
The proposed method has a lightweight yet powerful network structure , which consists of RDCL and MSCL .
The former enables FaceBoxes to achieve real - time speed , and the latter aims at enriching receptive fields and discretizing anchors over different layers to handle faces of various scales .
Besides , a new anchor densification strategy is proposed to improve the recall rate of small faces .
The experiments demonstrate that our contributions lead Face - Boxes to the state - of - the - art performance on the common face detection benchmarks .
The proposed detector is very fast , achieving 20 FPS for VGA - resolution images on CPU and can be accelerated to 125 FPS on GPU .
